import argparse
import re
import sys

HEADER_COMMENT = """###
# This Makefile was automatically generated by 'makemake.py'
# 
# Directly modifying this Makefile is allowed, but modifications may be overwritten by further uses of the makemake utility.
###
"""

TARGETS_COMMENT = """###
# Targets:
###
"""

OBJECTS_COMMENT = """###
# Intermediary objects:
###
"""

PHONIES_COMMENT = """###
# Phony targets:
###
"""

REGEX_POUND_INCLUDE = re.compile("#include\s\"(.*)\"")

MAIN = "main.c"
OUT = "main.out"
MAKEFILE = "Makefile"

SRCDIR     = "src"
INCLUDEDIR = "include"
BUILDDIR   = "obj"
BINDIR     = "bin"

SRCEXT = "c"
OBJEXT = "o"
HDREXT = "h"
OUTEXT = "out"

CC      = "clang"
CFLAGS  = "-Wall -Wextra -std=c2x -pedantic"
LDFLAGS = ""
DBFLAGS = "-g3 -glldb"

MODE_RELEASE = "RELEASE"
MODE_DEBUG   = "DEBUG"

def main(argv):
    argParser = argparse.ArgumentParser(description="A maker of Makefiles")

    argParser.add_argument("-v", 
                           "--verbose", 
                           action="store_true", 
                           help="Verbose output")
    argParser.add_argument("-m", 
                           "--mains", 
                           nargs="+",
                           action="extend",
                           type=str,
                           help=f"Main file (defaults to: {SRCDIR}/{MAIN})")
    argParser.add_argument("-o", 
                           "--out", 
                           default=OUT,
                           help=f"Output file (defaults to: {OUT})")
    argParser.add_argument("--cc",
                           default=CC,
                           help=f"Compiler (defaults to: {CC})")
    argParser.add_argument("--cflags",
                           default=CFLAGS,
                           help=f"Compiler flags (defaults to: {CFLAGS})")
    argParser.add_argument("--ldflags",
                           default=LDFLAGS,
                           help=f"Linker flags (defaults to: {LDFLAGS})")
    argParser.add_argument("--mode",
                           default=MODE_RELEASE,
                           choices=[MODE_RELEASE, MODE_DEBUG],
                           help=f"Compile mode (defaults to: {MODE_RELEASE})")
    argParser.add_argument("--srcdir",
                           default=SRCDIR,
                           help=f"Directory for source files (defaults to: {SRCDIR})")
    argParser.add_argument("--bindir",
                           default=BINDIR,
                           help=f"Directory for final binary file (defaults to: {BINDIR})")
    argParser.add_argument("--builddir",
                           default=BUILDDIR,
                           help=f"Directory for intermediary build files (defaults to: {BUILDDIR})")
    argParser.add_argument("--includedir",
                           default=INCLUDEDIR,
                           help=f"Directory for included header files (defaults to: {INCLUDEDIR})")
    argParser.add_argument("--srcext",
                           default=SRCEXT,
                           help=f"Extension for all source files (defaults to: {SRCEXT})")
    argParser.add_argument("--objext",
                           default=OBJEXT,
                           help=f"Extension for all object files (defaults to: {OBJEXT})")
    argParser.add_argument("--hdrext",
                           default=HDREXT,
                           help=f"Extension for all header files (defaults to: {HDREXT})")
    argParser.add_argument("--makefile",
                           default=MAKEFILE,
                           help=f"The name of the final Makefile (defaults to: {MAKEFILE})")

    args = argParser.parse_args(args=None if sys.argv[1:] else ['--help'])
    makemake(args)

##
# Entrypoint. Generates the Makefile using the provided arguments, writing the final output to the filesystem.
#
def makemake(args):
    header = make_header(args)
    linker_target = make_linker_targets(args)
    object_targets = make_object_targets(args)
    phony_targets = make_phony_targets(args)
    
    if args.verbose:
        out = header + linker_target + '\n'.join(t for t in object_targets) + phony_targets
        debug("makemake", "", out)
    
    with open(args.makefile, 'w') as out:
        out.write(f'{HEADER_COMMENT}\n')
        out.write(header)

        out.write(f'{TARGETS_COMMENT}\n')
        out.write(linker_target)
        
        out.write(f'{OBJECTS_COMMENT}\n')
        for t in object_targets:
            out.write(t + '\n')
        
        out.write(f'{PHONIES_COMMENT}\n')
        out.write(phony_targets)

##
# Creates the header section of the Makefile. This section consists mainly of arguments.
#
def make_header(args):
    cflags = args.cflags + " " + DBFLAGS if args.mode == MODE_DEBUG else args.cflags

    out = (
        f'CC      := {args.cc}\n'
        f'CFLAGS  := {cflags}\n'
        f'LDFLAGS := {args.ldflags}\n'
        f'\n.DEFAULT_GOAL: all\n\n'
        '\n'
    )
    return out

##
# Creates a target for each specified entrypoint in 'args.mains'.
# 
# Usually a project has only one entrypoint, but in the event that more than one exist (say, one for a CLI, one for a server, 
# or one for tests) then each entrypoint can be specified via a command line argument. For each entrypoint, a binary is linked.
#
# The general shape of the return of this function is as follows:
#
# all: <target1> <target2> ...
#
# <target1.out> : <target1.o>
#   ${CC} ${LDFLAGS} -o <target1.out> <target1.o>
#
# <target2.out> : <target2.o>
#   ${CC} ${LDFLAGS} -o <target2.out> <target2.o>
#
# ...
#
def make_linker_targets(args):
    all = []
    out = ""
    
    for main in args.mains:
        main_object_files = set()
        
        # The final target always directly depends upon itself (or at least, its source representation)!
        main_object_file = source_to_object(main, args)
        main_object_files.add(main_object_file)

        # Generate all #included dependencies of 'main'
        main_includes = get_included_headers(main, args)
        for h in main_includes:
            main_object_files.add(header_to_object(h, args))
        
        main_object_files_string = ' '.join(main_object_files)
        main_out = source_to_out(main, args)

        # Maintain a list of all targets for later
        all.append(main_out)

        # Build the target for the final binary (linker step)
        out = out + (
            f'{main_out} : {main_object_files_string}\n'
            f'\t@mkdir -p {args.bindir}\n'
            f'\t${{CC}} ${{LDFLAGS}} -o {main_out} {main_object_files_string}\n'
            f'\n'
        )

    if args.verbose:
        debug("make_main_target", "", out)

    return f'all: {" ".join(all)}\n\n{out}'

##
# Creates a target for all source files referenced from each specified entrypoint in this project.
# 
# Targets are only created if they directly or indirectly lead to the generation of the targets specified via command line arguments. This
# means that if a particular source file is not used, it will not be incorporated into a target. "Use" is determined by a walk through the
# "#include" directives in each source file, starting with those specified as entrypoints.
#
# See 'make_object_target'
def make_object_targets(args):
    targets = set()
    todo_headers = set()

    # In order to begin, the "root" source files are first inspected, and their corresponding targets are generated. In this case, "root"
    # simply implies that the source file was explicitly denoted as being an entrypoint via the "args.mains" command line argument.
    for main in args.mains:
        main_headers, target = make_object_target(main, args)
        targets.add(target)
        todo_headers.update(main_headers)

    # At this point, "todo_headers" contains a list of .h files found to be "#include"-ed by the entrypoint sources. Loop through these,
    # walking to their corresponding source files, and generating object targets for each. Every time a new "#include" is found, store it
    # back in "todo_headers" for continued calculation (but only do so if we have never seen that .h file before).
    completed_headers = set()
    while len(todo_headers) > 0:

        # Process the next header, walking to its source file and generating a target
        header = todo_headers.pop()
        source = header_to_source(header, args)
        completed_headers.add(header)
        
        # The target has been generated, store it for eventual return by this function
        next_headers, target = make_object_target(source, args)
        targets.add(target)

        # For all included headers of the just-finished file, only maintain those which we have not yet processed.
        for h in next_headers:
            if h in completed_headers:
                continue
            else:
                todo_headers.add(h)

    if args.verbose:
        debug("make_object_targets", "", targets)
    
    return targets

##
# Creates a target for the provided source filepath. For every header file found to be a dependency of this source file (determined
# simply by its inclusion in a "#include" directive) return the set of headers for later processing. The target and set of headers
# are collected into a tuple that is returned by this function.
#
# Example:
#
# foo.c:
#   #include <stdio.h>
#   #include "foo/bar.h"
#
# make_object_target("foo.c") =>
# tuple(0):
#   foo.o : foo.c bar.h
#       clang -Wall -c src/foo.c -o obj/foo.o
# tuple(1):
#   {"bar.h"}
#
def make_object_target(source_file, args):
    object_file = source_to_object(source_file, args)
    headers = get_included_headers(source_file, args)

    # Include all discovered header files as being dependencies of this source file
    header_dependencies = set()
    for header in headers:
        header_dependencies.add(f'{args.includedir}/{header}')

    out = (
        f'{object_file} : {source_file} {" ".join(header_dependencies)}\n'
        f'\t@mkdir -p $(dir {object_file})\n'
        f'\t${{CC}} ${{CFLAGS}} -I{args.includedir} -c {source_file} -o {object_file}\n'
    )

    if args.verbose:
        debug("make_object_target", "", out)

    return headers, out

##
# Creates static targets that always exist regardless of the source tree (a typical example is the 'clean' target).
#
def make_phony_targets(args):
    target_clean = (
        f'.PHONY : clean\n'
        f'clean :\n'
        f'\trm -rf {args.builddir}\n'
    )
    target_purge = (
        f'.PHONY : purge\n'
        f'purge : clean\n'
        f'\trm -rf {args.bindir}\n'
    )
    return '\n'.join([target_clean, target_purge])

##
# Searches for all of the '#include "..."' lines in file specified by the provided filepath.
# For each example of the '#include "..."', the inner included path will be returned in a set.
#
# Example:
#
# main.c:
#   #include <stdio.h>
#   #include "foo/bar.h"
#   #include "foo/baz.h"
#
# get_included_headers("main.c", args) => {"foo/bar.h", "foo/baz.h"}
#
def get_included_headers(filepath, args):
    includes = set()
    with open(filepath) as f:
        for line in f:
            match = re.search(REGEX_POUND_INCLUDE, line)
            if not match:
                continue

            include = match.group(1)
            includes.add(include)

    if args.verbose:
        debug("get_included_headers", filepath, includes)

    return includes

##
# Returns a string representing the provided header filepath (expected to be in the form that would be found in a source file,
# e.g.: "foo/bar.h") with an equivalent filepath representing this header's source's object file. This path is expected to
# be a complete and valid filepath, and will include the "args.builddir" value as its parent directory.
#
# Example:
#
# objext = o
# hdrext = h
#
# header_to_object("foo/bar.h", args) => "obj/foo/bar.o"
#
def header_to_object(filepath, args):
    out = filepath.replace(args.hdrext, args.objext)
    out = f'{args.builddir}/{out}'

    if args.verbose:
        debug("header_to_object", filepath, out)

    return out

##
# Returns a string representing the provided header filepath (expected to be in the form that would be found in a source file,
# e.g.: "foo/bar.h") with an equivalent filepath representing this header's source file. This path is expected to
# be a complete and valid filepath, and will include the "args.srcdir" value as its parent directory.
#
# Example:
#
# srcext = c
# hdrext = h
#
# header_to_source("foo/bar.h", args) => "src/foo/bar.c"
#
def header_to_source(filepath, args):
    out = filepath.replace(args.hdrext, args.srcext)
    out = f'{args.srcdir}/{out}'

    if args.verbose:
        debug("header_to_source", filepath, out)

    return out

##
# Returns a string representing the provided source filepath with an equivalent filepath representing this file's header file. 
# This path is expected to be a complete and valid filepath, and will include the "args.includedir" value as its parent directory.
#
# Example:
#
# srcext = c
# hdrext = h
#
# header_to_source("src/foo/bar.c", args) => "include/foo/bar.h"
#
def source_to_header(filepath, args):
    out = filepath.replace(args.srcext, args.hdrext)
    out = re.sub(r'^.*?\/', f'{args.includedir}/', out)

    if args.verbose:
        debug("source_to_header", filepath, out)

    return out

##
# Returns a string representing the provided source filepath with an equivalent filepath representing this file's object file. 
# This path is expected to be a complete and valid filepath, and will include the "args.builddir" value as its parent directory.
#
# Example:
#
# srcext = c
# objext = o
#
# source_to_object("src/foo/bar.c", args) => "obj/foo/bar.o"
#
def source_to_object(filepath, args):
    out = filepath.replace(args.srcext, args.objext)
    out = re.sub(r'^.*?\/', f'{args.builddir}/', out)

    if args.verbose:
        debug("source_to_object", filepath, out)

    return out

##
# Returns a string representing the provided source filepath with an equivalent filepath representing this file's out file. 
# This path is expected to be a complete and valid filepath, and will include the "args.bindir" value as its parent directory.
#
# Example:
#
# srcext = c
# outext = out
#
# source_to_out("src/foo/bar.c", args) => "bin/foo/bar.out"
#
def source_to_out(filepath, args):
    out = filepath.replace(args.srcext, OUTEXT)
    out = re.sub(r'^.*?\/', f'{args.bindir}/', out)

    if args.verbose:
        debug("source_to_out", filepath, out)

    return out

def debug(function, input, output):
    print(f"{function}('{input}') =>\n{output}\nend {function}\n")

##
# Program entrypoint (test)
#
if __name__ == '__main__':
    main(sys.argv[1:])

##
# Program entrypoint (release)
#
def cli():
    if (len(sys.argv) <= 1):
        main("")
    main(sys.argv[1:])
